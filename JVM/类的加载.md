# 类的加载
![image](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png)
## 加载
- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

## 连接
-  ### 验证
    - **目的：** 为了确保Class文件的字节流中包括的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全
    1. **文件格式验证：** 验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理；该验证阶段是基于二进制字节流进行的，主要目的是确保输入的字节流能正确地解析并存储于方法区之内，
    2. **元数据验证：** 对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求（该类是否有父类，是否继承了不能继承的类，是否实现了父类或接口中要求实现的方法...）
    3. **字节码验证：** 通过数据流和控制流分析，确定程序语义是合法的符合逻辑的。
    4. **符号引用验证：** 验证符号引用转化为直接引用的合法性，确保解析动作能够正常执行
* ### 准备
    * 正式为==类变量==分配内存并设置类变量==初始值==的阶段，这些变量所使用的内存都在方法区中进行分配。
    * ==类变量==指的是被static修饰的变量，而不是实例变量。
    * ==初始值==:“通常情况”下是数据类型的零值，“特殊情况”下：如果字段被声明为常量，那么在编译时虚拟机就会为该字段生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue将该字段的初始值设为常量值。
* ### 解析
    -  ==虚拟机将常量池内的符号引用替换为直接引用的过程。==
    -  ==符号引用==: 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义地定位到目标即可。
    -  ==直接引用==:可以是直接指向目标的指针、相对偏移量或者是一个能够间接定位到目标的句柄。

## 初始化
* 初始化阶段是执行类构造器<clinit>()方法的过程。
* 初始化的情形:
    * new： 使用new关键字实例化对象的时候。
    - getstatic/putstatic：读取或设置一个类的静态字段。
    - invokestatic：调用一个类的静态方法  
    - 对类进行反射调用的时候。如果没有进行初始化，则需要先触发其初始
    - 若父类没有进行初始化，则先父后子。
    - 虚拟机启动时，会先初始化指定的主类
    - 使用动态语言支持时，若实例的最后解析结果的方法句柄，其方法句柄所对应的类没有进行过初始化
* <clinit>() 方法是由编译器自动收集类中的所有==类变量==的赋值动作和==静态语句块== (static{}块）中的语句合并产生的， 编译器收集的顺序是由语句在源文件中出现的 顺序所决定的， 静态语句块中只能访问到定义在静态语句块之前的变虽， 定义在它 之后的变量， 在前面的静态语句块可以赋值， 但是不能访问.
* **<clinit>()** 方法与类的构造函数（或者说实例构造器<init>()方法）不同， 它不需要式地调用父类构造器， 虚拟机会保证在==子类的<clinit>()方法执行之前， 父类的<clinit>()方法已经执行完毕==。 因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。
* 接口中不能使用静态代码块，但仍有变量初始化的赋值操作，因此接口与类一般都会生成<clinit>()方法。==但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父类接口的<clinit>()方法，只有当父类接口中定义的变量使用时，父类接口才会初始化，另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法==
* 虚拟机会保证一个类的<clinit>（）方法在多线程环境中被正确地==加锁、同步==，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<chnit>() 方法，其他线程都需要阻塞等待， 直到活动线程执行<clinit>()方法完毕。

## 卸载
- 卸载类即该类的Class对象被GC
- 卸载类需要满足3个要求:
    - 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
    - 该类没有在其他任何地方被引用
    - 该类的类加载器的实例已被GC
- 所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

- 只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。