![image](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png)

- ## 类加载检查
    JVM在创建个指令的参数是否能在常量池中定位到这个类的符号引用==,并且检查这个符号引用代表的==类是否已被加载过==、解析和初始化过。如果没有，那必须先执行相应的类加载过程

- ## 分配内存

- ### 分配方式
    - #### 指针碰撞法
        - 使用场合: 堆内存规整(没有内存碎片)的情况下
        - 原理: 用过的内存全部整个到一边,没有用过的内存放在另一边,中间有一个分界指针,只需要向着没有用过的内存方向将该指针移动对象内存大小的位置即可
        - GC收集器:Serial,ParNew
    - #### 空闲列表法
        - 使用场合:堆内存不规整的情况下
        - 原理:虚拟机会维护一个列表,该列表中会记录哪些内存块是可用的,在分配的时候,找一块足够大小的内存块出来划分给实例对象,最后更新列表记录
        - GC收集器:CMS
    - #### 线程安全问题 
        - 创建对象是很频繁的操作,虚拟机在为新建对象分配内存的时候要保证线程安全,不然会出事
        - 解决方法:
            - ==CAS+失败重试==:CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
            - ==TLAB：== 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

- ## 初始化零值
    内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），== 这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用 ==，程序能访问到这些字段的数据类型所对应的零值。 
    
- ## 设置对象头
    初始化零值完成之后，虚拟机要对对象进行必要的设置，==例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中==。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
    
- ## 执行init方法(构造方法)
    在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来
    
    ### 参考博客
    
    [https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=31-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%88%9b%e5%bb%ba](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java内存区域?id=31-对象的创建)

