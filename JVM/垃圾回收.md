- ## JVM堆内存
![image](http://i2.51cto.com/images/blog/201808/21/b116170771ecb3117ae7fead03fcaa0d.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)
- #### 堆内存
    存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回
- #### 非堆内存 
    元空间(永久代)，方法区的实现，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等

# GC
- 新生成的对象首先放到年轻代Eden区，==当Eden空间满了，触发Minor GC==，存活下来的对象移动到Survivor0区，==Survivor0区满后触发执行Minor GC==，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。
老年代存储长期存活的对象，占满时会触发==Major GC=Full GC==，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时
- 在GC开始的时候,对象只会存在于Eden区和名为From的Survivor区,Survivor区的TO区是空的.紧接着进行Minor GC,Eden区中所有存活的兑现都会被复制到To区中,而在From区中仍存活的对象会根据他们的年龄值来决定去向.年龄到达一定值(年龄阀值,可以通过-XX:MaxTenuringThreshold来设置)的对象会被移到老年代中,没有达到年龄阀值的对象会被复制到To区域.经过这次GC后,Eden区和From区已经被清空,这个时候,From区和To区会交换他们的角色,也就是新的To区就是上次GC前的From,新的From就是上次CG前的To,不过怎样都会保证名为To的区是空的.Minor GC会一直重复这样的过程,直到To区被填满,填满后会将To区所有的对象移到老年代中

# 如何分配对象
- ### 对象优先在Eden区分配
    大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.
- ### 大对象直接进入老年代
    为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率,类如字符串,数组这种大对象会直接进入老年代 
- ### 长期存活的对象进入老年代
    虚拟机给每个对象一个对象年龄（Age）计数器。
如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的==年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中==。对象晋升到老年代的年龄阈值，可以通过参数 ==-XX:MaxTenuringThreshold== 来设置
- ### 动态年龄判断
    Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，==当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”==

# 如何判断对象死亡
- ### 引用计数法
    - 实现:给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的
    - 优点:实现简单，效率高
    - 缺点:它很难解决对象之间相互循环引用的问题
- ### 可达性分析法
    - 实现:这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的
    ![image](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/72762049.jpg)
# 垃圾回收算法
- ### 标记-清除算法
    - #### 过程:
        首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
    ![image](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/63707281.jpg)
    - #### 缺陷
        - 效率问题
        - 产生空间碎片
- ### 复制算法
    - #### 过程:
        将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收
    ![image](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/90984624.jpg)
    - 缺陷:浪费了一半的内存空间 
- ### 标记-整理算法
    - #### 过程
        标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存
        ![image](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/94057049.jpg)
    - 缺陷:时间成本高
- ### JVM的分代收集算法
    - JVM会根据不同年代的特点,选择适合各个年代的垃圾收集算法
    - 新生代--->赋值算法
        - 每次收集都会有大量对象死去,选择复制算法只需要付出少量对象的复制成本就可以完成每次垃圾收集
    - 老年代--->标记-清除/标记-整理
        - 老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保

# 垃圾收集器
[点击查看详细的垃圾收集器解析](https://blog.csdn.net/lijingyao8206/article/details/80513383)
- ### 串行垃圾回收器
JDK 1.3之前的垃圾回收器，==单线程回收==，并且会有stop theworld（下文会简称STW），也即==GC时，暂停所有用户线程==。其运行方式是单线程的，==适合Client模式的应用==，适合单CPU环境。串行的垃圾收集器有两种，Serial以及SerialOld，一般会搭配使用。新生代使用Serial采取复制算法，老年代使用Serial Old采取标记整理算法。Client应用或者命令行程序可以，通过-XX:+UseSerialGC可以开启上述回收模式。
- **Serial**：用于新生代垃圾收集，复制算法
- **SerialOld**：用于老年代垃圾收集，标记整理算法

- ### 并行垃圾回收器
整体来说，并行垃圾回收相对于串行，是通过多线程运行垃圾收集的。也会stop-the-world。适合Server模式以及多CPU环境。一般会和jdk1.5之后出现的CMS搭配使用。并行的垃圾回收器有以下几种：
- **ParNew**：Serial收集器的多线程版本，默认开启的收集线程数和cpu数量一样，运行数量可以通过修改ParallelGCThreads设定。用于新生代收集，复制算法。使用-XX:+UseParNewGC,和Serial Old收集器组合进行内存回收。
- **Parallel Scavenge**: 关注吞吐量,吞吐量优先，吞吐量=代码运行时间/(代码运行时间+垃圾收集时间),也就是高效率利用cpu时间，尽快完成程序的运算任务
    可以设置最大停顿时间MaxGCPauseMillis以及，吞吐量大小GCTimeRatio。如果设置了-XX:+UseAdaptiveSizePolicy参数，则随着GC,会动态调整新生代的大小，Eden,Survivor比例等，以提供最合适的停顿时间或者最大的吞吐量。用于新生代收集，复制算法。通过-XX:+UseParallelGC参数，Server模式下默认提供了其和SerialOld进行搭配的分代收集方式。
- **Parllel Old**：Parallel Scavenge的老年代版本。JDK 1.6开始提供的。在此之前Parallel Scavenge的地位也很尴尬，而有了Parllel Old之后，通过-XX:+UseParallelOldGC参数使用Parallel Scavenge + Parallel Old器组合进行内存回收。 
- ### CMS收集器
    - CMS（Concurrent Mark Sweep）收集器是一种以==获取最短回收停顿时间为目标==的收集器。它非常符合在注重用户体验的应用上使用。
    - CMS是 HotSpot 虚拟机第一款真正意义上的==并发收集器==，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作
    - -XX:UseConcMarkSweepGC参数可以开启CMS,年轻代使用ParNew，老年代使用CMS，同时Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用
    - 优点:
        - 并发收集、低停顿
    - 缺点:
        - 对 CPU 资源敏感；
            - 在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢，总吞吐量会降低
        - 无法处理浮动垃圾；
            - CMS在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS无法再当次过程中处理，所以只有等到下次gc时候在清理掉，这一部分垃圾就称作“浮动垃圾”  
        - 它使用的回收算法-“标记-清除”算法会导致收集结束时==会有大量空间碎片产生==。
    - 运行过程:
        - 初始标记： 记录下直接与 root 相连的对象，速度很快,==会"Stop The World"==；
        - 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
        - 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，执行时间相对并发标记短，==会“Stop The World”==
        - 并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。
        - ![image](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/82825079.jpg)
- ### G1收集器
    - G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征
    - 从整体来说，G1也是==利用多CPU来缩短stop the world时间，并且是高效的并发垃圾收集器==
    - 通过“-XX:+UseG1GC”启动参数即可指定使用G1 GC
    - G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）
    - 特点:
        - G1的堆结构就是把一整块内存区域切分成多个固定大小的块(region)  
        - 这些region最后又被分别标记为Eden,Survivor和old。这里的eden，survivor和old已经是一个标签，也就是说只是一个逻辑表示，不是物理表示
        - 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
        - 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
        - 空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
        - 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
    - 运行过程:
        - 初始标记:标记GC Roots能直接关联的对象，速度很快。stop the word
        - 并发标记:从GC Roots出发，对堆中对象进行可达性分析，找出存活对象，该阶段耗时较长，但是可与用户线程并发执行。
        - 最终标记:主要修正在并发标记阶段因为用户线程继续运行而导致标记记录产生变动的那一部分对象的标记记录。stop the word
        - 筛选回收:将各个region分区的回收价值和成本进行排序，根据用户所期望的停顿时间制定回收计划。这阶段停顿用户线程。stop the word